use std::{collections::HashMap, ops::Deref, sync::Arc, time::Duration};

use crate::{
    models::{
        channel_config::{ChannelConfig, ChannelSubscription},
        cves::CVE,
        last_checked_cve::{self, LastCheckedCVE},
    },
    schema::channel_subscription,
    Context, Error, GlobalData,
};
use poise::{
    serenity_prelude::{ChannelId, Http, MessageBuilder},
    Framework,
};
use serde_json::Value;

pub fn setup(global_data: GlobalData, http_client: Arc<Http>) -> () {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(5));
        loop {
            interval.tick().await;
            let _ = notify_new_cves(Arc::clone(&global_data), Arc::clone(&http_client))
                .await
                .map_err(|error| {
                    eprintln!("Failed to run notify_new_cves task: {error:?}");
                });
        }
    });
}

// TODO
pub async fn notify_new_cves(global_data: GlobalData, http_client: Arc<Http>) -> Result<(), Error> {
    let mut database_connection = global_data.db_pool.get().await?;
    let mut opencve_database_connection = global_data.opencve_db_pool.get().await?;

    let last_checked_cve_publish_date = LastCheckedCVE::get_last(&mut database_connection).await?;
    let mut cves_to_notify: Vec<CVE> = CVE::get_unreported(
        last_checked_cve_publish_date,
        &mut opencve_database_connection,
    )
    .await?;

    cves_to_notify.sort_by(|a, b| a.publish_date.cmp(&b.publish_date));

    if cves_to_notify.len() == 0 {
        return Ok(());
    }

    for cve in cves_to_notify {
        let flatten_affected_vendors_and_products = cve
            .affected_vendors
            .iter()
            .map(|affected_vendors| {
                let mut pre_flatten = affected_vendors.products.clone();
                pre_flatten.push(affected_vendors.vendor.clone());
                pre_flatten.into_iter().collect::<Vec<_>>()
            })
            .flatten()
            .collect::<Vec<_>>();

        let flatten_affected_vendors_and_products = flatten_affected_vendors_and_products
            .iter()
            .map(String::as_str)
            .collect::<Vec<_>>();

        let affected_subscribed_channels = ChannelConfig::get_affected_subscriptions(
            flatten_affected_vendors_and_products.as_slice(),
            &mut database_connection,
        );
    }

    // TODO send in parallel
    // for (ChannelId(channel_id), embeds) in notify_queue {
    //     embeds.chunks(10).for_each(|embeds| {
    //         http_client.send_message(channel_id, http_client.send_message(channel_id, map)).await?;
    //     })
    // }

    todo!();
    Ok(())
}
