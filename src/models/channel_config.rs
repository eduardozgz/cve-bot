use crate::{
    schema::{self, channel_config},
    Error,
};

use super::guild_config::GuildConfig;
use diesel::prelude::*;
use diesel_async::{AsyncPgConnection, RunQueryDsl};

#[derive(Queryable, Selectable, Associations, Debug)]
#[diesel(table_name = crate::schema::channel_config)]
#[diesel(belongs_to(GuildConfig, foreign_key = guild_id))]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct ChannelConfig {
    pub id: String,
    pub guild_id: String,
    pub opencve_frontend_url: Option<String>,
}

#[derive(Insertable, AsChangeset)]
#[diesel(table_name = crate::schema::channel_config)]
pub struct NewChannelConfig<'a> {
    pub id: &'a str,
    pub guild_id: &'a str,
    pub opencve_frontend_url: Option<&'a str>,
}

#[derive(diesel_derive_enum::DbEnum)]
#[ExistingTypePath = "crate::schema::sql_types::SubscriptionKind"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum SubscriptionKind {
    Vendor,
    Product,
}

#[derive(Queryable, Selectable, Associations, PartialEq, Eq, Hash)]
#[diesel(table_name = crate::schema::channel_subscription)]
#[diesel(belongs_to(ChannelConfig, foreign_key = channel_id))]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct ChannelSubscription {
    pub channel_id: String,
    pub kind: SubscriptionKind,
    pub name: String,
}

#[derive(Insertable)]
#[diesel(table_name = crate::schema::channel_subscription)]
pub struct NewChannelSubscription<'a> {
    pub channel_id: &'a str,
    pub kind: SubscriptionKind,
    pub name: &'a str,
}

impl ChannelConfig {
    /// Ensure that all necessary tables and basic data are created
    pub async fn load(
        channel_id: &String,
        guild_id: &String,
        database_connection: &mut AsyncPgConnection,
    ) -> Result<ChannelConfig, Error> {
        GuildConfig::load(guild_id, database_connection).await?;

        let default_guild_config = NewChannelConfig {
            id: &channel_id,
            guild_id,
            opencve_frontend_url: None,
        };

        diesel::insert_into(channel_config::table)
            .values(&default_guild_config)
            .on_conflict(channel_config::id)
            .do_nothing()
            .execute(database_connection)
            .await?;

        let channel_config_data = channel_config::table
            .filter(channel_config::id.eq(&channel_id))
            .select(ChannelConfig::as_select())
            .get_result(database_connection)
            .await?;

        Ok(channel_config_data)
    }

    pub async fn subscribe(
        self,
        kind: SubscriptionKind,
        names: &[&str],

        database_connection: &mut AsyncPgConnection,
    ) -> Result<(), Error> {
        use schema::channel_subscription;

        let subscriptions = names
            .into_iter()
            .map(|name| NewChannelSubscription {
                channel_id: &self.id,
                kind,
                name,
            })
            .collect::<Vec<_>>();

        diesel::insert_into(channel_subscription::table)
            .values(&subscriptions)
            .on_conflict((channel_subscription::name, channel_subscription::kind))
            .do_nothing()
            .execute(database_connection)
            .await?;

        Ok(())
    }

    pub async fn unsubscribe(
        self,
        kind: SubscriptionKind,
        names: &[&str],
        database_connection: &mut AsyncPgConnection,
    ) -> Result<(), Error> {
        use schema::channel_subscription::{self, dsl};

        let mut query = diesel::delete(dsl::channel_subscription).into_boxed();

        query = query.filter(channel_subscription::channel_id.eq(&self.id));
        query = query.filter(channel_subscription::kind.eq(kind));

        if !names.contains(&"*") {
            query = query.filter(channel_subscription::name.eq_any(names));
        }

        query.execute(database_connection).await?;

        Ok(())
    }

    pub async fn get_affected_subscriptions(
        names: &[&str],
        database_connection: &mut AsyncPgConnection,
    ) -> Result<Vec<ChannelSubscription>, Error> {
        use schema::channel_subscription;

        let affected_subscriptions: Vec<ChannelSubscription> = channel_subscription::table
            .filter(channel_subscription::name.eq_any(names))
            .select(ChannelSubscription::as_select())
            .get_results(database_connection)
            .await?;

        Ok(affected_subscriptions)
    }
}
