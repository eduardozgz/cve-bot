use crate::models::channel_config::SubscriptionKind;
use crate::models::cves::{CVEAffectedVendorProducts, CVECVSSV2, CVECVSSV3};
use crate::schema::channel_config;
use crate::{
    models::{
        channel_config::ChannelConfig, cves::CVE, guild_config::GuildConfig,
        last_checked_cve::LastCheckedCVE,
    },
    opencve_frontend::OpenCVEFrontend,
    Error, GlobalData,
};
use diesel::prelude::*;
use diesel_async::{AsyncPgConnection, RunQueryDsl};
use poise::serenity_prelude::Colour;
use poise::serenity_prelude::{model::id::ChannelId, CreateEmbed, Http};
use std::{collections::HashMap, sync::Arc, time::Duration};
use tokio::task::JoinSet;

type CVEId = String;

pub fn setup(global_data: GlobalData, http_client: Arc<Http>) -> () {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(5));
        loop {
            interval.tick().await;
            let _ = notify_new_cves(Arc::clone(&global_data), Arc::clone(&http_client))
                .await
                .map_err(|error| {
                    eprintln!("Failed to run notify_new_cves task: {error:?}");
                });
        }
    });
}

async fn notify_new_cves(global_data: GlobalData, http_client: Arc<Http>) -> Result<(), Error> {
    let mut database_connection = global_data.db_pool.get().await?;
    let mut opencve_database_connection = global_data.opencve_db_pool.get().await?;

    let cves_to_notify: HashMap<CVEId, CVE> =
        get_new_cves(&mut database_connection, &mut opencve_database_connection).await?;

    let affected_subscribed_channels: HashMap<
        ChannelId,
        Vec<(CVEId, Vec<CVEAffectedVendorProducts>)>,
    > = get_affected_subscribed_channels(&cves_to_notify, &mut database_connection).await?;

    let cves_to_notify: Arc<HashMap<String, CVE>> = Arc::new(cves_to_notify);

    let mut tasks: JoinSet<()> = JoinSet::new();
    for (channel, affected_cves) in affected_subscribed_channels {
        let http_client = Arc::clone(&http_client);
        let global_data = Arc::clone(&global_data);
        let cves_to_notify = Arc::clone(&cves_to_notify);

        tasks.spawn(async move {
            let channel_id_str = channel.to_string();

            let affected_cves = affected_cves
                .into_iter()
                .map(|affected_cve| (cves_to_notify.get(&affected_cve.0).unwrap(), affected_cve.1))
                .collect();

            if let Err(err) =
                notify_channel((channel, affected_cves), http_client, global_data).await
            {
                eprintln!(
                    "Something went wrong when trying to notify the channel {}: {:?}",
                    channel_id_str, err
                );
            };
        });
    }
    while let Some(_) = tasks.join_next().await {}

    Ok(())
}

async fn get_new_cves(
    database_connection: &mut AsyncPgConnection,
    opencve_database_connection: &mut AsyncPgConnection,
) -> Result<HashMap<CVEId, CVE>, Error> {
    let mut last_checked_cve_publish_date = LastCheckedCVE::get_last(database_connection).await?;

    let new_cves: HashMap<CVEId, CVE> =
        CVE::get_unreported(last_checked_cve_publish_date, opencve_database_connection)
            .await?
            .into_iter()
            .map(|cve| (cve.cve_id.to_owned(), cve))
            .collect();

    // Find and update last_checked_cve_publish_date
    for (_, cve) in &new_cves {
        if cve.publish_date.gt(&last_checked_cve_publish_date) {
            last_checked_cve_publish_date = cve.publish_date.to_owned();
        }
    }

    LastCheckedCVE::set_last(last_checked_cve_publish_date, database_connection).await?;

    return Ok(new_cves);
}

async fn get_affected_subscribed_channels(
    cves: &HashMap<String, CVE>,
    database_connection: &mut AsyncPgConnection,
) -> Result<HashMap<ChannelId, Vec<(CVEId, Vec<CVEAffectedVendorProducts>)>>, Error> {
    let mut affected_subscribed_channels: HashMap<
        String,
        HashMap<CVEId, HashMap<String, CVEAffectedVendorProducts>>,
    > = HashMap::new();

    for (cve_id, cve) in cves {
        let flat_affected_vendors_and_products = cve
            .affected_vendors
            .iter()
            .map(|affected_vendors| {
                let mut pre_flatten = affected_vendors.products.clone();
                pre_flatten.push(affected_vendors.vendor.clone());
                pre_flatten.into_iter().collect::<Vec<_>>()
            })
            .flatten()
            .collect::<Vec<_>>();

        let flat_affected_vendors_and_products = flat_affected_vendors_and_products
            .iter()
            .map(String::as_str)
            .collect::<Vec<_>>();

        let channel_subscriptions = ChannelConfig::get_affected_subscriptions(
            flat_affected_vendors_and_products.as_slice(),
            database_connection,
        )
        .await?;

        channel_subscriptions
            .into_iter()
            .for_each(|channel_subscription| {
                let channel_id = channel_subscription.channel_id.to_owned();

                cve.affected_vendors.iter().for_each(|affected_vendor| {
                    match channel_subscription.kind {
                        SubscriptionKind::Vendor => {
                            if !affected_vendor.vendor.eq(&channel_subscription.name) {
                                return;
                            }

                            affected_subscribed_channels
                                .entry(channel_id.to_owned())
                                .or_default()
                                .entry(cve_id.to_owned())
                                .or_default()
                                .entry(affected_vendor.vendor.to_owned())
                                .or_insert(CVEAffectedVendorProducts {
                                    vendor: affected_vendor.vendor.to_owned(),
                                    products: vec![],
                                })
                                .products = affected_vendor.products.to_owned();
                        }
                        SubscriptionKind::Product => {
                            if !affected_vendor
                                .products
                                .iter()
                                .any(|product_name| product_name.eq(&channel_subscription.name))
                            {
                                return;
                            }

                            let products = &mut affected_subscribed_channels
                                .entry(channel_id.to_owned())
                                .or_default()
                                .entry(cve_id.to_owned())
                                .or_default()
                                .entry(affected_vendor.vendor.to_owned().to_owned())
                                .or_insert(CVEAffectedVendorProducts {
                                    vendor: affected_vendor.vendor.to_owned().to_owned(),
                                    products: vec![],
                                })
                                .products;

                            if !products.contains(&channel_subscription.name) {
                                products.push(channel_subscription.name.to_owned());
                            }
                        }
                    };
                });
            })
    }

    let affected_subscribed_channels: HashMap<
        ChannelId,
        Vec<(CVEId, Vec<CVEAffectedVendorProducts>)>,
    > = affected_subscribed_channels
        .into_iter()
        .map(|(channel_id, cves)| {
            let channel_id = ChannelId(match channel_id.parse() {
                Ok(v) => v,
                Err(e) => {
                    eprintln!("{e:?}");
                    return None;
                }
            });

            Some((
                channel_id,
                cves.into_iter()
                    .map(|(cve_id, affected_vendor_products)| {
                        (
                            cve_id,
                            affected_vendor_products.into_iter().map(|a| a.1).collect(),
                        )
                    })
                    .collect(),
            ))
        })
        .filter(|i| i.is_some())
        .map(|i| i.unwrap())
        .collect();

    Ok(affected_subscribed_channels)
}

async fn notify_channel(
    (channel, affected_cves): (ChannelId, Vec<(&CVE, Vec<CVEAffectedVendorProducts>)>),
    http_client: Arc<Http>,
    global_data: GlobalData,
) -> Result<(), Error> {
    let mut database_connection: deadpool::managed::Object<
        diesel_async::pooled_connection::AsyncDieselConnectionManager<AsyncPgConnection>,
    > = global_data.db_pool.get().await?;
    let channel_config: ChannelConfig = channel_config::table
        .filter(channel_config::id.eq(&channel.to_string()))
        .select(ChannelConfig::as_select())
        .get_result(&mut database_connection)
        .await?;

    let guild_config: GuildConfig =
        GuildConfig::load(&channel_config.guild_id, &mut database_connection).await?;

    let opencve_frontend = OpenCVEFrontend::new(
        guild_config.opencve_frontend_url.as_deref(),
        channel_config.opencve_frontend_url.as_deref(),
        &global_data.config.opencve_default_frontend,
    );

    let mut affected_cves = affected_cves;

    affected_cves.sort_by(|a, b| a.0.publish_date.cmp(&b.0.publish_date));

    for affected_cve in affected_cves {
        let embed = build_cve_embed(affected_cve, &opencve_frontend);

        channel
            .send_message(&http_client, |m| m.add_embeds(vec![embed]))
            .await?;
    }

    Ok(())
}

fn build_cve_embed(
    (cve, affected_vendor_products): (&CVE, Vec<CVEAffectedVendorProducts>),
    opencve_frontend: &OpenCVEFrontend,
) -> CreateEmbed {
    let mut embed = CreateEmbed(HashMap::new());
    let mut color: Option<Colour> = None;

    embed
        .title(cve.cve_id.clone())
        .url(opencve_frontend.get_cve_url(cve.cve_id.as_str()))
        .description(cve.summary.clone())
        .timestamp(cve.publish_date);

    if let Some(CVECVSSV3 {
        severity,
        score,
        impact_score,
        exploitability_score,
        scope,
        attack_vector,
        vector_string,
        integrity_impact,
        user_interaction,
        attack_complexity,
        availability_impact,
        privileges_required,
        confidentiality_impact,
    }) = &cve.cvss_v3
    {
        color = compute_severity_color(severity);
        embed.field(
            format!("CVSS v3: `{score}/10` **({severity})**"),
            format!(
                "
            Exploitability: `{exploitability_score}`\n\
            Impact: `{impact_score}`\n\
            `{vector_string}`\n\
            Attack Vector: `{attack_vector}`\n\
            Attack Complexity: `{attack_complexity}`\n\
            Privileges Required: `{privileges_required}`\n\
            User Interaction: `{user_interaction}`\n\
            Confidentiality Impact: `{confidentiality_impact}`\n\
            Integrity Impact: `{integrity_impact}`\n\
            Availability Impact: `{availability_impact}`\n\
            Scope: `{scope}`\n\
            "
            ),
            false,
        );
    }

    if let Some(CVECVSSV2 {
        severity,
        score,
        impact_score,
        exploitability_score,
        access_vector,
        vector_string,
        authentication,
        integrity_impact,
        access_complexity,
        availability_impact,
        confidentiality_impact,
    }) = &cve.cvss_v2
    {
        if let None = color {
            color = compute_severity_color(severity);
        }

        embed.field(
            format!("CVSS v2: `{score}/10` **({severity})**"),
            format!(
                "
            Exploitability: `{exploitability_score}`\n\
            Impact: `{impact_score}`\n\
            `{vector_string}`\n\
            Access Vector: `{access_vector}`\n\
            Access Complexity: `{access_complexity}`\n\
            Authentication: `{authentication}`\n\
            Confidentiality Impact: `{confidentiality_impact}`\n\
            Integrity Impact: `{integrity_impact}`\n\
            Availability Impact: `{availability_impact}`\n\
            "
            ),
            false,
        );
    }

    let mut affected_str = String::new();
    affected_vendor_products
        .iter()
        .for_each(|CVEAffectedVendorProducts { vendor, products }| {
            let vendor_url = opencve_frontend.get_search_vendor_url(&vendor);
            affected_str.push_str(format!("- [{vendor}]({vendor_url})\n").as_str());

            products.iter().for_each(|product| {
                let product_url = opencve_frontend.get_search_product_url(&product);
                affected_str.push_str(format!(" - [{product}]({product_url})\n").as_str());
            });
        });

    embed.field(format!("**Your affected products**"), affected_str, false);

    if let Some(color) = color {
        embed.color(color);
    }

    embed
}

fn compute_severity_color(severity: &str) -> Option<Colour> {
    match severity {
        "CRITICAL" => Some(Colour(0x972b1e)),
        "HIGH" => Some(Colour(0xdd4b39)),
        "MEDIUM" => Some(Colour(0xf39c12)),
        "LOW" => Some(Colour(0x00c0ef)),
        "NONE" => None,
        _ => None,
    }
}
