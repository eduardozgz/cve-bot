use crate::models::cves::{CVECVSSV2, CVECVSSV3};
use crate::schema::channel_config;
use crate::{
    models::{
        channel_config::{ChannelConfig, ChannelSubscription},
        cves::CVE,
        guild_config::GuildConfig,
        last_checked_cve::LastCheckedCVE,
    },
    opencve_frontend::OpenCVEFrontend,
    Error, GlobalData,
};
use diesel::prelude::*;
use diesel_async::{AsyncPgConnection, RunQueryDsl};
use poise::serenity_prelude::Colour;
use poise::serenity_prelude::{model::id::ChannelId, CreateEmbed, Http};
use std::{
    collections::{HashMap, HashSet},
    sync::Arc,
    time::Duration,
};
use tokio::task::JoinSet;

type CVEId = String;

pub fn setup(global_data: GlobalData, http_client: Arc<Http>) -> () {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(5));
        loop {
            interval.tick().await;
            let _ = notify_new_cves(Arc::clone(&global_data), Arc::clone(&http_client))
                .await
                .map_err(|error| {
                    eprintln!("Failed to run notify_new_cves task: {error:?}");
                });
        }
    });
}

// TODO detect and warn when vendor/products are added when a CVE is updated

async fn notify_new_cves(global_data: GlobalData, http_client: Arc<Http>) -> Result<(), Error> {
    let mut database_connection = global_data.db_pool.get().await?;
    let mut opencve_database_connection = global_data.opencve_db_pool.get().await?;

    let cves_to_notify: HashMap<String, CVE> =
        get_new_cves(&mut database_connection, &mut opencve_database_connection).await?;

    let affected_subscribed_channels: HashMap<ChannelId, Vec<CVEId>> =
        get_affected_subscribed_channels(&cves_to_notify, &mut database_connection).await?;

    let cves_to_notify: Arc<HashMap<String, CVE>> = Arc::new(cves_to_notify);

    let mut tasks = JoinSet::new();
    for affected_channel in affected_subscribed_channels {
        let http_client = Arc::clone(&http_client);
        let global_data = Arc::clone(&global_data);
        let cves_to_notify = Arc::clone(&cves_to_notify);

        tasks.spawn(async move {
            let channel_id_str = affected_channel.0.to_string();

            if let Err(err) =
                notify_channel(affected_channel, cves_to_notify, http_client, global_data).await
            {
                eprintln!(
                    "Something went wrong when trying to notify the channel {}: {:?}",
                    channel_id_str, err
                );
            };
        });
    }
    while let Some(_) = tasks.join_next().await {}

    Ok(())
}

async fn get_new_cves(
    database_connection: &mut AsyncPgConnection,
    opencve_database_connection: &mut AsyncPgConnection,
) -> Result<HashMap<CVEId, CVE>, Error> {
    let mut last_checked_cve_publish_date = LastCheckedCVE::get_last(database_connection).await?;

    let new_cves: HashMap<CVEId, CVE> =
        CVE::get_unreported(last_checked_cve_publish_date, opencve_database_connection)
            .await?
            .into_iter()
            .map(|cve| (cve.cve_id.to_owned(), cve))
            .collect();

    // Find and update last_checked_cve_publish_date
    for (_, cve) in &new_cves {
        if cve.publish_date.gt(&last_checked_cve_publish_date) {
            last_checked_cve_publish_date = cve.publish_date.to_owned();
        }
    }

    LastCheckedCVE::set_last(last_checked_cve_publish_date, database_connection).await?;

    return Ok(new_cves);
}

async fn get_affected_subscribed_channels(
    cves: &HashMap<String, CVE>,
    database_connection: &mut AsyncPgConnection,
) -> Result<HashMap<ChannelId, Vec<CVEId>>, Error> {
    let mut affected_subscribed_channels: HashMap<ChannelId, HashSet<CVEId>> = HashMap::new();

    for (cve_id, cve) in cves {
        let flat_affected_vendors_and_products = cve
            .affected_vendors
            .iter()
            .map(|affected_vendors| {
                let mut pre_flatten = affected_vendors.products.clone();
                pre_flatten.push(affected_vendors.vendor.clone());
                pre_flatten.into_iter().collect::<Vec<_>>()
            })
            .flatten()
            .collect::<Vec<_>>();

        let flat_affected_vendors_and_products = flat_affected_vendors_and_products
            .iter()
            .map(String::as_str)
            .collect::<Vec<_>>();

        ChannelConfig::get_affected_subscriptions(
            flat_affected_vendors_and_products.as_slice(),
            database_connection,
        )
        .await?
        .into_iter()
        .for_each(|affected_channel: ChannelSubscription| {
            let channel_key = ChannelId(match affected_channel.channel_id.parse() {
                Ok(v) => v,
                Err(e) => {
                    eprintln!("{e:?}");
                    return ();
                }
            });

            affected_subscribed_channels
                .entry(channel_key)
                .or_default()
                .insert(cve_id.to_owned());
        });
    }

    // Convert HashSet to Vector
    let affected_subscribed_channels = affected_subscribed_channels
        .into_iter()
        .map(|(channel_id, hash_set)| (channel_id, hash_set.into_iter().collect()))
        .collect();

    Ok(affected_subscribed_channels)
}

async fn notify_channel(
    affected_channel: (ChannelId, Vec<CVEId>),
    cves_to_notify: Arc<HashMap<String, CVE>>,
    http_client: Arc<Http>,
    global_data: GlobalData,
) -> Result<(), Error> {
    let mut database_connection: deadpool::managed::Object<
        diesel_async::pooled_connection::AsyncDieselConnectionManager<AsyncPgConnection>,
    > = global_data.db_pool.get().await?;
    let (channel, cves) = affected_channel;
    let channel_config: ChannelConfig = channel_config::table
        .filter(channel_config::id.eq(&channel.0.to_string()))
        .select(ChannelConfig::as_select())
        .get_result(&mut database_connection)
        .await?;

    let guild_config: GuildConfig =
        GuildConfig::load(&channel_config.guild_id, &mut database_connection).await?;

    let opencve_frontend = OpenCVEFrontend::new(
        guild_config.opencve_frontend_url.as_deref(),
        channel_config.opencve_frontend_url.as_deref(),
        &global_data.config.opencve_default_frontend,
    );

    let mut cves: Vec<&CVE> = cves
        .iter()
        .map(|cve_id| cves_to_notify.get(cve_id).unwrap())
        .collect();

    cves.sort_by(|a, b| a.publish_date.cmp(&b.publish_date));

    for cve in cves {
        let embed = build_cve_embed(cve, &opencve_frontend);

        channel
            .send_message(&http_client, |m| m.add_embeds(vec![embed]))
            .await?;
    }

    Ok(())
}

fn build_cve_embed(cve: &CVE, opencve_frontend: &OpenCVEFrontend) -> CreateEmbed {
    let mut embed = CreateEmbed(HashMap::new());
    let mut color: Option<Colour> = None;

    embed
        .title(cve.cve_id.clone())
        .url(opencve_frontend.get_cve_url(cve.cve_id.as_str()))
        .description(cve.summary.clone())
        .timestamp(cve.publish_date);

    if let Some(CVECVSSV3 {
        severity,
        score,
        impact_score,
        exploitability_score,
        scope,
        attack_vector,
        vector_string,
        integrity_impact,
        user_interaction,
        attack_complexity,
        availability_impact,
        privileges_required,
        confidentiality_impact,
    }) = &cve.cvss_v3
    {
        color = compute_severity_color(severity);
        embed.field(
            format!("CVSS v3: `{score}/10` **({severity})**"),
            format!(
                "
            Exploitability: `{exploitability_score}`\n\
            Impact: `{impact_score}`\n\
            `{vector_string}`\n\
            Attack Vector: `{attack_vector}`\n\
            Attack Complexity: `{attack_complexity}`\n\
            Privileges Required: `{privileges_required}`\n\
            User Interaction: `{user_interaction}`\n\
            Confidentiality Impact: `{confidentiality_impact}`\n\
            Integrity Impact: `{integrity_impact}`\n\
            Availability Impact: `{availability_impact}`\n\
            Scope: `{scope}`\n\
            "
            ),
            false,
        );
    }

    if let Some(CVECVSSV2 {
        severity,
        score,
        impact_score,
        exploitability_score,
        access_vector,
        vector_string,
        authentication,
        integrity_impact,
        access_complexity,
        availability_impact,
        confidentiality_impact,
    }) = &cve.cvss_v2
    {
        if let None = color {
            color = compute_severity_color(severity);
        }

        embed.field(
            format!("CVSS v2: `{score}/10` **({severity})**"),
            format!(
                "
            Exploitability: `{exploitability_score}`\n\
            Impact: `{impact_score}`\n\
            `{vector_string}`\n\
            Access Vector: `{access_vector}`\n\
            Access Complexity: `{access_complexity}`\n\
            Authentication: `{authentication}`\n\
            Confidentiality Impact: `{confidentiality_impact}`\n\
            Integrity Impact: `{integrity_impact}`\n\
            Availability Impact: `{availability_impact}`\n\
            "
            ),
            false,
        );
    }

    // TODO show affected vendors
    embed.field(
        format!("**Your affected products**"),
        format!("(// TODO hehe)",),
        false,
    );

    if let Some(color) = color {
        embed.color(color);
    }

    embed
}

fn compute_severity_color(severity: &str) -> Option<Colour> {
    match severity {
        "CRITICAL" => Some(Colour(0x972b1e)),
        "HIGH" => Some(Colour(0xdd4b39)),
        "MEDIUM" => Some(Colour(0xf39c12)),
        "LOW" => Some(Colour(0x00c0ef)),
        "NONE" => None,
        _ => None,
    }
}
