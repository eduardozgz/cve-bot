use crate::{opencve_schema::cves, Error};
use chrono::{DateTime, Utc};
use diesel::{prelude::*, AsExpression, FromSqlRow};
use diesel_as_jsonb::AsJsonb;
use diesel_async::{AsyncPgConnection, RunQueryDsl};
use serde::{self, Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

const RAW_AFFECTED_VENDOR_SEPARATOR: &str = "$PRODUCT$";

#[derive(Queryable, Selectable, Deserialize)]
#[diesel(table_name = cves)]
#[diesel(check_for_backend(diesel::pg::Pg))]

struct CVEModel {
    #[serde(skip)]
    pub cve_id: String,

    #[serde(skip)]
    pub created_at: DateTime<Utc>,

    #[serde(skip)]
    pub summary: String,

    pub json: Option<CVEModelJSON>,

    pub vendors: Option<Value>,
}

#[derive(Debug, Serialize, Deserialize, AsJsonb)]
struct CVEModelJSON {
    pub impact: CVEModelJSONImpact,
}

#[derive(Debug, Serialize, Deserialize, AsJsonb)]
struct CVEModelJSONImpact {
    #[serde(rename = "baseMetricV2")]
    pub base_metric_v2: Option<CVEModelJSONImpactBaseMetricV2>,

    #[serde(rename = "baseMetricV3")]
    pub base_metric_v3: Option<CVEModelJSONImpactBaseMetricV3>,
}

#[derive(Debug, Serialize, Deserialize, AsJsonb)]
struct CVEModelJSONImpactBaseMetricV2 {
    #[serde(rename = "cvssV2")]
    pub cvss_v2: CVEModelJSONImpactBaseMetricV2CVSS,

    pub severity: String,

    #[serde(rename = "impactScore")]
    pub impact_score: f64,

    #[serde(rename = "exploitabilityScore")]
    pub exploitability_score: f64,
}

#[derive(Debug, Serialize, Deserialize, AsJsonb)]
struct CVEModelJSONImpactBaseMetricV2CVSS {
    #[serde(rename = "baseScore")]
    base_score: f64,

    #[serde(rename = "accessVector")]
    access_vector: String,

    #[serde(rename = "vectorString")]
    vector_string: String,

    #[serde(rename = "authentication")]
    authentication: String,

    #[serde(rename = "integrityImpact")]
    integrity_impact: String,

    #[serde(rename = "accessComplexity")]
    access_complexity: String,

    #[serde(rename = "availabilityImpact")]
    availability_impact: String,

    #[serde(rename = "confidentialityImpact")]
    confidentiality_impact: String,
}

#[derive(Debug, Serialize, Deserialize, AsJsonb)]
struct CVEModelJSONImpactBaseMetricV3 {
    #[serde(rename = "cvssV3")]
    pub cvss_v3: CVEModelJSONImpactBaseMetricV3CVSS,

    #[serde(rename = "impactScore")]
    pub impact_score: f64,

    #[serde(rename = "exploitabilityScore")]
    pub exploitability_score: f64,
}

#[derive(Debug, Serialize, Deserialize, AsJsonb)]
struct CVEModelJSONImpactBaseMetricV3CVSS {
    #[serde(rename = "baseScore")]
    base_score: f64,

    #[serde(rename = "scope")]
    pub scope: String,

    #[serde(rename = "attackVector")]
    pub attack_vector: String,

    #[serde(rename = "baseSeverity")]
    pub base_severity: String,

    #[serde(rename = "vectorString")]
    pub vector_string: String,

    #[serde(rename = "integrityImpact")]
    pub integrity_impact: String,

    #[serde(rename = "userInteraction")]
    pub user_interaction: String,

    #[serde(rename = "attackComplexity")]
    pub attack_complexity: String,

    #[serde(rename = "availabilityImpact")]
    pub availability_impact: String,

    #[serde(rename = "privilegesRequired")]
    pub privileges_required: String,

    #[serde(rename = "confidentialityImpact")]
    pub confidentiality_impact: String,
}

#[derive(Debug)]
pub struct CVE {
    pub cve_id: String,
    pub publish_date: DateTime<Utc>,
    pub summary: String,
    pub affected_vendors: Vec<CVEAffectedVendorProducts>,
    pub cvss_v2: Option<CVECVSSV2>,
    pub cvss_v3: Option<CVECVSSV3>,
}

#[derive(Debug)]
pub struct CVEAffectedVendorProducts {
    pub vendor: String,
    pub products: Vec<String>,
}

#[derive(Debug)]
pub struct CVECVSSV2 {
    pub severity: String,
    pub score: f64,
    pub impact_score: f64,
    pub exploitability_score: f64,
    pub access_vector: String,
    pub vector_string: String,
    pub authentication: String,
    pub integrity_impact: String,
    pub access_complexity: String,
    pub availability_impact: String,
    pub confidentiality_impact: String,
}

#[derive(Debug)]
pub struct CVECVSSV3 {
    pub severity: String,
    pub score: f64,
    pub impact_score: f64,
    pub exploitability_score: f64,
    pub scope: String,
    pub attack_vector: String,
    pub vector_string: String,
    pub integrity_impact: String,
    pub user_interaction: String,
    pub attack_complexity: String,
    pub availability_impact: String,
    pub privileges_required: String,
    pub confidentiality_impact: String,
}

impl CVE {
    pub async fn get_unreported(
        from: DateTime<Utc>,
        database_connection: &mut AsyncPgConnection,
    ) -> Result<Vec<CVE>, Error> {
        let raw_cves: Vec<CVEModel> = cves::table
            .select(CVEModel::as_select())
            .filter(cves::created_at.gt(from))
            .get_results(database_connection)
            .await?;

        let cves = raw_cves
            .into_iter()
            .map(|raw_cve| {
                let raw_cve_json = raw_cve.json.unwrap();

                Self {
                    cve_id: raw_cve.cve_id,
                    publish_date: raw_cve.created_at,
                    summary: raw_cve.summary,
                    affected_vendors: CVE::parse_raw_vendors(raw_cve.vendors),
                    cvss_v2: raw_cve_json
                        .impact
                        .base_metric_v2
                        .map(|raw_cvss2| CVE::parse_raw_cvss2(raw_cvss2)),
                    cvss_v3: raw_cve_json
                        .impact
                        .base_metric_v3
                        .map(|raw_cvss3| CVE::parse_raw_cvss3(raw_cvss3)),
                }
            })
            .collect();

        Ok(cves)
    }

    fn parse_raw_vendors(raw_vendors: Option<Value>) -> Vec<CVEAffectedVendorProducts> {
        let raw_vendors = match raw_vendors.unwrap_or_default() {
            Value::Array(arr) => arr,
            Value::Null => vec![],
            unknown => panic!("Unexpected type found for raw_cve.vendors: {unknown:?}"),
        };

        let mut affected_vendors_products_map: HashMap<String, Vec<String>> = HashMap::new();

        raw_vendors.into_iter().for_each(|raw_vendor| {
            let raw_vendor_and_product: String = match raw_vendor {
                Value::String(vendor_or_product) => vendor_or_product,
                unknown => {
                    panic!("Unexpected type found for raw_cve.vendors[i]: {unknown:?}")
                }
            };

            let mut vendor_and_product =
                raw_vendor_and_product.split(RAW_AFFECTED_VENDOR_SEPARATOR);

            let vendor_name = vendor_and_product.next();

            let vendor_name = if let Some(vendor_name) = vendor_name {
                vendor_name.to_string()
            } else {
                return;
            };

            let map_entry = affected_vendors_products_map
                .entry(vendor_name)
                .or_default();

            let product_name = vendor_and_product.next();
            if let Some(product_name) = product_name {
                map_entry.push(product_name.to_string());
            };
        });

        affected_vendors_products_map
            .into_iter()
            .map(|(vendor, products)| CVEAffectedVendorProducts {
                vendor: vendor.to_string(),
                products: products,
            })
            .collect()
    }

    fn parse_raw_cvss2(raw: CVEModelJSONImpactBaseMetricV2) -> CVECVSSV2 {
        CVECVSSV2 {
            severity: raw.severity,
            score: raw.cvss_v2.base_score,
            impact_score: raw.impact_score,
            exploitability_score: raw.exploitability_score,
            access_vector: raw.cvss_v2.access_vector,
            vector_string: raw.cvss_v2.vector_string,
            authentication: raw.cvss_v2.authentication,
            integrity_impact: raw.cvss_v2.integrity_impact,
            access_complexity: raw.cvss_v2.access_complexity,
            availability_impact: raw.cvss_v2.availability_impact,
            confidentiality_impact: raw.cvss_v2.confidentiality_impact,
        }
    }

    fn parse_raw_cvss3(raw: CVEModelJSONImpactBaseMetricV3) -> CVECVSSV3 {
        CVECVSSV3 {
            severity: raw.cvss_v3.base_severity,
            score: raw.cvss_v3.base_score,
            impact_score: raw.impact_score,
            exploitability_score: raw.exploitability_score,
            scope: raw.cvss_v3.scope,
            attack_vector: raw.cvss_v3.attack_vector,
            vector_string: raw.cvss_v3.vector_string,
            integrity_impact: raw.cvss_v3.integrity_impact,
            user_interaction: raw.cvss_v3.user_interaction,
            attack_complexity: raw.cvss_v3.attack_complexity,
            availability_impact: raw.cvss_v3.availability_impact,
            privileges_required: raw.cvss_v3.privileges_required,
            confidentiality_impact: raw.cvss_v3.confidentiality_impact,
        }
    }
}
